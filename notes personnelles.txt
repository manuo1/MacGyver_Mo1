ajoueter un test d'overflow sur la creation des item a collecter

bum bag = sac bananne



f string => f"{a} à {b} €"

Pour l'affichage des sprites, une bonne méthodes est de créer des instances héritant de pygame.sprite.Sprite dans un groupe de type pygame.sprite.Group.
C'est la manière classique de procéder en pygame et ça permet de gérer l'affichage en une ligne (enfin, quelques lignes)
------------------------------------------------------------------------------------------------------------------------------------

def draw_paths(self, background, paths):
    path_image = pygame.image.load("/path/to/image").convert()
    for path in paths:
        x, y = path
        background.blit(path_image, (x * SPRITE_WIDTH, y * SPRITE_HEIGHT))
-----------------------------------------------------------------------------------------------------------
L'arrière-plan est une image que tu donnes à Pygame. Tu "colles" ensuite tes sprites dessus.

-------------------------------------------------------------------------------------------------------------
Par ailleurs, prend l'habitude dès le début de documenter tes méthodes avec des docstrings.
Pas
# Documentation de ma méthode d'initialisation
def __init__(self, param1, param2):

Mais
class MaClasse:
    """Documentation de la classe et de ses attributs.

    Attributes:
        attribute1: Documentation de attribute1.
        attribute2: ...

    """

    def __init__(self, param1, param2):
        """Documentation de la méthode d'initialisation.

        Args:
            param1: Documentation du paramètre 1
            param2: ...

        """





Important:

1. N'utilisez pas l'étoile dans les imports
2. A part les imports, pas de code en dehors d'une methode, d'une classe ou d'une fonction
3. Au début, partez sur une règle d'organisation simple: une classe - un module (mieux vaut surdécouper son code que ne pas découper du tout)
4. Nommer chaque package et module avec un mot descriptif de son contenu, en minuscules. Pas de class, classes, functions, etc. Pour le module,
    le nom de la classe qu'il contient en minuscule me semble une bonne idée de départ.
5. Comme vous multipliez les modules, groupez-les dans au min. un package. Pas de module .py au niveau de votre README (sauf un éventuel setup.py)
6. Respectez les règles de nommage de la PEP8: MaClasse, UNE_CONSTANTE, une_variable, une_methode_ou_fonction.
7. Utilisez des constantes plutôt que des nombres magiques dans votre code: NUMBER_ITEMS = 3, LABYRINTH_WIDTH = 15, SPRITE_SIZE = 40, etc. et définissez
    ces variables dans un même fichier (p.ex. settings.py ou config.py).
8. Eliminer tous les prints de vos classes de logique.
9. Débuggez avec un debugger, pas avec des prints
10. Même si vous utilisez pycharm, activez vos environnements virtuels à la main, lancez vos programmes à la main avec python -m package.mainmodule (option -m et pas de .py à la fin).
____________________________________________________________________________________________________________________________________________________________________________________


les étapes qu'il faut retenir:
- partir des objets
- identifier les attributs et méthodes
- identifier les classes
- créer un module par classe et créer les squelettes pour chaque classe
- décrire chaque methode en pseudo-code
- traduire le pseudo-code en python ligne par ligne. Si c'est encore trop compliqué, créer des méthodes privées pour simplifier
- valider le projet
____________________________________________________________________________________________________________________________________________________________________________________

Suite à une discussion avec un étudiant, voici la suite d'outils que je recommande pour finaliser un projet avant soutenance et s'assurer sa qualité du point de vue d'un certain nombre de bonnes pratiques. La première étape est de lire les pep8 et 257 (http://nguyen.univ-tln.fr/share/Python/pep8.pdf)
flake8
    installation: pipenv install flake8 --dev
    lancement: flake8 à la racine du projet
    description: Affiche un diagnostique des erreurs de pep8
autopep8
    installation: pipenv install autopep8 --dev
    lancement: autopep8 --recursive --in-place . à la racine du projet (le point a de l'importance)
    description: Corrige automatiquement de nombreuses erreurs de pep8
isort
    installation: pipenv install "isort[requirements,pipfile]" --dev
    lancement: isort -rc . à la racine du projet
    description: Trie les imports automatiqument
docformatter
    installation: pipenv install docformatter --dev
    lancement: docformatter --recursive --in-place . à la racine du projet
    description: Formate automatiquement les docstrings de manière conforme à la PEP 257

Pour le formattage automatique, j'utilise black, qui est plus agressif que autopep8, mais qui formate également le code pour éviter les lignes trop longues. J'installe black avec pipenv install black --pre --dev et je lance avec black --line-length 79 -t py37 -S .  (le point a de l'importance et l'option -S a été recommandée par @SebDeclercq ci-dessous pour désactiver l'uniformisation des guillemets). Il est également possible de lancer black directement depuis son éditeur et d'utiliser l'option "Format on save" pour ne plus avoir à y penser. @Zepman | Benjamin nous donne un lien ici: https://discordapp.com/channels/347061157351260161/347074846313938944/694266884643881002

Note sur l'usage de pipenv. C'est ici un choix de ma part basé sur ma pratique personnelle. N'hésitez pas à remplacer les commandes pipenv par pip et à enlever les options --dev dans ce cas.
